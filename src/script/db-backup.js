const { Sequelize } = require('sequelize');
const fs = require('fs-extra');
const path = require('path');
const moment = require('moment');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

// const BACKUP_DIR = path.join(__dirname, 'backups');
const BACKUP_DIR = path.resolve(__dirname, '../../../../db-backup');
const today = moment().format('YYYY-MM-DD');
const FILE_NAME = `backup-${today}.sql`;
const todayDir = path.join(BACKUP_DIR, today);
const filePath = path.join(todayDir, FILE_NAME);

const sequelize = new Sequelize(
  process.env.DATABASE_PRIMARY_NAME,
  process.env.DATABASE_PRIMARY_USER,
  process.env.DATABASE_PRIMARY_PASSWORD,
  {
    host: process.env.DATABASE_PRIMARY_HOST,
    dialect: process.env.DATABASE_PRIMARY_CLIENT,
    port: process.env.DATABASE_PRIMARY_PORT,
    timezone: process.env.DATABASE_PRIMARY_TIMEZONE,
    dialectOptions: {
      ssl: false,
    },
    logging: false,
  }
);

// Helper to format values properly
function formatValue(val, fieldName, tableName) {
  if (val === null || val === undefined) {
    return 'NULL';
  }

 if (
    Array.isArray(val) &&
    typeof fieldName === 'string' &&
    typeof tableName === 'string' &&
    fieldName === 'week_days' &&
    tableName === 'member_schedules'
  ) {
    const pgArray = `{${val.join(',')}}`;
    return `'${pgArray}'`;
  }

  // General case for arrays -> JSON string
  if (Array.isArray(val)) {
    try {
      return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
    } catch {
      return 'NULL';
    }
  }

  if (val instanceof Date) {
    return `'${moment(val).format('YYYY-MM-DD HH:mm:ssZ')}'`;
  }

  if (typeof val === 'boolean') {
    return val ? 'TRUE' : 'FALSE';
  }

  if (typeof val === 'object') {
    try {
      return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
    } catch {
      return 'NULL';
    }
  }

  return `'${val.toString().replace(/'/g, "''")}'`;
}



async function backup() {
  await fs.ensureDir(todayDir);
  let dump = `-- Backup for CockroachDB on ${today}\n\n`;

  const [tables] = await sequelize.query(`
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
  `);

for (const { table_name } of tables) {
  // Get CREATE TABLE statement
  try {
    const [createResult] = await sequelize.query(`SHOW CREATE TABLE "${table_name}"`);
    const createStmt = createResult['create_statement']
      .replace('CREATE TABLE', 'CREATE TABLE IF NOT EXISTS')
      .replace(/DEFAULT nextval\('[^']*'::REGCLASS\)/gi, 'GENERATED BY DEFAULT AS IDENTITY');

    dump += `--\n-- Table structure for "${table_name}"\n--\n${createStmt};\n\n`;
  } catch (err) {
    console.warn(`Could not get CREATE TABLE for "${table_name}":`, err.message);
    continue;
  }

  // Get data
  const [rows] = await sequelize.query(`SELECT * FROM "${table_name}"`);
  if (rows.length > 0) {
    dump += `--\n-- Data for table "${table_name}"\n--\n`;

    rows.forEach(row => {
      const cols = Object.keys(row).map(col => `"${col}"`).join(', ');
      const vals = Object.entries(row)
        .map(([col, val]) => formatValue(val, col, table_name))
        .join(', ');

      dump += `INSERT INTO "${table_name}" (${cols}) VALUES (${vals}) ON CONFLICT DO NOTHING;\n`;
    });

    dump += '\n';

    // Try to reset sequence if table has a serial or identity primary key
    try {
      const [pkInfo] = await sequelize.query(`
        SELECT
          a.attname AS column_name,
          s.relname AS sequence_name
        FROM pg_class t
        JOIN pg_index i ON t.oid = i.indrelid AND i.indisprimary
        JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(i.indkey)
        JOIN pg_depend d ON d.refobjid = t.oid AND d.refobjsubid = a.attnum
        JOIN pg_class s ON s.oid = d.objid AND s.relkind = 'S'
        WHERE t.relname = '${table_name}'
      `);

      if (pkInfo.length > 0) {
        const { column_name, sequence_name } = pkInfo[0];
        dump += `-- Reset sequence for ${table_name}.${column_name}\n`;
        dump += `SELECT setval('${sequence_name}', (SELECT MAX("${column_name}") FROM "${table_name}"));\n\n`;
      }
    } catch (seqErr) {
      console.warn(`Could not determine sequence for "${table_name}":`, seqErr.message);
    }
  }
}


  await fs.writeFile(filePath, dump, 'utf-8');
  console.log(`Backup created at: ${filePath}`);

  await cleanOldBackups();
}

async function cleanOldBackups() {
  const folders = await fs.readdir(BACKUP_DIR);
  for (const folder of folders) {
    const fullPath = path.join(BACKUP_DIR, folder);
    if ((await fs.stat(fullPath)).isDirectory()) {
      const folderDate = moment(folder, 'YYYY-MM-DD');
      if (moment().diff(folderDate, 'days') > 7) {
        await fs.remove(fullPath);
        console.log(`Deleted old backup: ${fullPath}`);
      }
    }
  }
}

backup()
  .catch(err => console.error('Backup failed:', err))
  .finally(() => sequelize.close());
